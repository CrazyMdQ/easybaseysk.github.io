<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP 是什麼</title>
    <link rel="stylesheet" href="../css/textpage_style.css">
    <style>
        #d3_container {
            width: 100%;
            height: 400px;
            border: solid 1px #ccc;
            margin-top: 20px;
        }
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 3px;
        }
        .node text {
            font: 12px sans-serif;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
    </style>
</head>
<body>
    <div class="container" id="thing">
    
        
    <a href="../index.html">&larr; 返回首頁</a>
    <h1>MCP 是什麼</h1>
    <p>本篇文章將介紹 MCP (Model-Controller-Presenter) 的概念，這是一種在軟體開發中用於組織程式碼的架構模式。</p>

    <h2>1. MCP 的定義</h2>
    <p>MCP 是一種軟體架構模式，它將應用程式的邏輯分為三個互相連接的部分，分別是模型 (Model)、控制器 (Controller) 和展示器 (Presenter)。這種模式旨在實現關注點分離 (Separation of Concerns)，使得程式碼更容易維護、測試和擴展。</p>

    <h2>2. MCP 的核心組成</h2>
    <ul>
        <li><b>模型 (Model)</b>：負責處理應用程式的資料和業務邏輯。它不關心資料如何被顯示，只專注於資料本身的管理。</li>
        <li><b>控制器 (Controller)</b>：接收使用者的輸入，並根據輸入調用模型和展示器來更新資料和視圖。它是模型和展示器之間的協調者。</li>
        <li><b>展示器 (Presenter)</b>：從模型中獲取資料，並將其格式化後傳遞給視圖 (View) 進行顯示。它負責處理所有與顯示相關的邏輯。</li>
    </ul>

    <div id="d3_container"></div>

    <h2>3. MCP 與 MVC 的比較</h2>
    <p>MCP 模式與常見的 MVC (Model-View-Controller) 模式非常相似，但主要區別在於展示器 (Presenter) 的角色。在 MVC 中，視圖可以直接從模型中獲取資料；而在 MCP 中，展示器作為中介，負責從模型獲取資料並提供給視圖，這使得視圖變得更加被動和簡單。</p>

    <h2>4. MCP 的優點</h2>
    <ul>
        <li><b>高度的模組化</b>：各個組件職責分明，易於獨立開發和測試。</li>
        <li><b>易於維護</b>：修改一個組件不會輕易影響到其他組件。</li>
        <li><b>更好的可測試性</b>：由於業務邏輯和顯示邏輯分離，可以針對各個部分進行單元測試。</li>
    </ul>

    </div>
    <script src="../lib-js/d3.js"></script>
    <script>
        const data = {
            "name": "MCP",
            "children": [
                {
                    "name": "模型",
                    "children": [
                        { "name": "資料和業務邏輯" }
                    ]
                },
                {
                    "name": "控制器",
                    "children": [
                        { "name": "使用者輸入" },
                        { "name": "更新模型和展示器" }
                    ]
                },
                {
                    "name": "展示器",
                    "children": [
                        { "name": "從模型獲取資料" },
                        { "name": "格式化資料供視圖顯示" }  
                    ]
                }
            ]
        };

        const width = document.getElementById('d3_container').offsetWidth;
        const height = document.getElementById('d3_container').offsetHeight;

        const tree = d3.tree().size([height, width - 280]);

        const root = d3.hierarchy(data);
        tree(root);

        const svg = d3.select("#d3_container").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(80,0)");

        const link = svg.selectAll(".link")
            .data(root.links())
            .enter().append("path")
            .attr("class", "link")
            .attr("d", d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x));

        const node = svg.selectAll(".node")
            .data(root.descendants())
            .enter().append("g")
            .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
            .attr("transform", d => `translate(${d.y},${d.x})`);

        node.append("circle")
            .attr("r", 10);

        node.append("text")
            .attr("dy", ".35em")
            .attr("x", d => d.children ? -13 : 13)
            .style("text-anchor", d => d.children ? "end" : "start")
            .text(d => d.data.name);
    </script>
</body>
</html>